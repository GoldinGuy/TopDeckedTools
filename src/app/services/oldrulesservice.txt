export interface RulesData {
    [id: string]: RuleTopic;
}

export interface RuleTopic {
    [id: string]: RuleSubTopic;
}

export interface RuleSubTopic {
    [id: string]: RuleInstance[];
}

export type RuleInstance = string;

import { Injectable } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { LoadingController } from '@ionic/angular';
import rules from './rules_txt';
import { JsonpClientBackend } from '@angular/common/http';
import { THIS_EXPR } from '@angular/compiler/src/output/output_ast';

export interface IRulesService {
    // Direct get methods
    getAllTopicIds(): string[];
    getAllSubTopicIds(topicId: string): string[];
    getSubTopic(topic: RuleTopic, id: string): RuleInstance[];

    // Keyword Lookup
    getKeywordDefinition(keyword: string): RuleInstance;

    // Query methods
    findAllTopicsMatching(term: string): RuleTopic;
    findAllSubTopicsMatching(topic: RuleTopic, term: string): RuleSubTopic;
    findAllRuleInstancesMatching(topic: RuleSubTopic, term: string): RuleSubTopic;
}

@Injectable({ providedIn: 'root' })
export class RulesService {
    // component_name: any;
    // subsection: RuleSubsection;
    // section: RuleSection;
    searchReference;
    topics: string[];
    // ruleTopics: Array<RuleTopic[]>;
    // ruleSubTopics: Array<RuleSubTopic[]>;
    // ruleInstances: Array<RuleInstance[]>;
    glossary: string;

    constructor(public loadingController: LoadingController) {
        this.topics = Object.keys(rules);
        this.searchReference = {};

        // by default glossary is currently this.topics[9] but in case the order ever changes this will ensure it continues to work
        for (let i = 0; i < this.topics.length; i++) {
            if (this.topics[i].toLowerCase() == 'glossary') {
                this.glossary = this.topics[i];
            }
        }
    }

    // Direct get methods
    getAllTopicIds(): string[] {
        return this.topics;
    }

    getAllSubTopicIds(topicId: string): string[] {
        return Object.keys(rules[topicId]);
    }

    getSubTopic(topic: RuleTopic, id: string): RuleInstance[] {
        let subtopic = rules[topic][id];
        if (typeof subtopic === 'string') {
            subtopic = [subtopic];
        }
        return subtopic;
    }

    getTopicFromSubtopic(subtopic: string): RuleTopic[] {
        for (let i = 0; i < this.topics.length; i++) {
            if (this.topics[i].startsWith(subtopic.substring(0, 1))) {
                return rules[this.topics[i]];
            }
        }
    }

    getTopicIdFromSubtopicId(subtopicLabel: string): string {
        for (let i = 0; i < this.topics.length; i++) {
            if (this.topics[i].startsWith(subtopicLabel.substring(0, 1))) {
                return this.topics[i];
            }
        }
    }

    // Keyword Lookup
    getKeywordDefinition(keyword: string): RuleInstance {
        let def: string = '';
        keyword = keyword
            .toLowerCase()
            .split(' ')
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
        if (!this.isRule(keyword) && keyword != null && keyword != '') {
            def = rules[this.glossary][keyword];
        }
        return def;
    }

    // Query methods
    findAllInstancesMatching(term: string): string[] {
        if (term == null || term == '') {
            return this.topics;
        } else {
            let temp = [];
            Object.keys(rules).forEach((key) => {
                let subrule = rules[key];
                Object.keys(subrule).forEach((subkey) => {
                    let detail = rules[key][subkey];
                    let added = false;
                    if (typeof detail !== 'object') {
                        detail = [detail];
                    }
                    detail.forEach((explanation) => {
                        if (explanation.toLowerCase().search(term) !== -1 && !added) {
                            temp.push(subkey);
                            this.searchReference[subkey] = key;
                            added = true;
                        }
                    });
                });
            });

            if (temp.length >= 1) {
                return temp;
            } else {
                return ['No results found :('];
            }
        }
    }

    // findAllSubTopicsMatching(topic: RuleTopic, term: string): Array<RuleSubTopic> {
    //     if (term == null || term == '') {
    //         return rules[this.topics];
    //     } else {
    //         let temp: Array<RuleSubTopic>;
    //         for (const subtopic in topic) {
    //             // check subtopic for match against term and add to result if it does
    //             if (subtopic.includes(term)) {
    //                 temp.push(rules[topic[subtopic]]);
    //             }
    //         }
    //         return temp;
    //     }
    // }

    findAllSubTopicsMatching(
        topic: RuleTopic,
        term: string
    ): Array<RuleSubTopic & { title: string }> {
        if (term == null || term == '') {
            return [];
        }
        topic = topic || {};
        return Object.keys(topic).map((key) => ({ title: key, ...topic[key] })).filter((sub) => sub.includes(term));
    }

    // findAllSubTopicsMatching(term: string): RuleSubTopic[] {
    //     if (term == null || term == '') {
    //         return rules[this.topics];
    //     } else {
    //         let temp: RuleSubTopic[];
    //         Object.keys(rules).forEach((key) => {
    //             let subrule = rules[key];
    //             Object.keys(subrule).forEach((subkey) => {
    //                 let detail = rules[key][subkey];
    //                 let added = false;
    //                 if (typeof detail !== 'object') {
    //                     detail = [detail];
    //                 }

    //                 detail.forEach((explanation) => {
    //                     if (explanation.toLowerCase().search(term) !== -1 && !added) {
    //                         temp.push(subkey);
    //                         this.searchReference[subkey] = key;
    //                         added = true;
    //                     }
    //                 });
    //             });
    //         });
    //         return temp;
    //     }
    // }

    // returns all subrules matching a given term
    getAllRulesMatching(searchTerm) {
        if (searchTerm == null || searchTerm == '') {
            return this.topics;
        } else {
            // this.array = ['Loading...'];

            let temp = [];
            Object.keys(rules).forEach((key) => {
                let subrule = rules[key];
                Object.keys(subrule).forEach((subkey) => {
                    let detail = rules[key][subkey];
                    let added = false;
                    if (typeof detail !== 'object') {
                        detail = [detail];
                    }

                    detail.forEach((explanation) => {
                        if (explanation.toLowerCase().search(searchTerm) !== -1 && !added) {
                            temp.push(subkey);
                            this.searchReference[subkey] = key;
                            added = true;
                        }
                    });
                });
            });

            if (temp.length >= 1) {
                return temp;
            } else {
                return ['No results found :('];
            }
        }
    }

    // returns a given rules section (an array of subcategories containing further levels of rule abstraction)
    getRuleSecById(sectionrule: string) {
        return Object.keys(rules[sectionrule]);
    }
    // returns a given rules subsection (an array of detailed rules with descriptions)
    getRuleSubSecById(sectionrule, rule) {
        let subsection = rules[sectionrule][rule];
        if (typeof subsection === 'string') {
            subsection = [subsection];
        }
        return subsection;
    }

    // determine if a given rule is numeric or a glossary term
    isRule(ruleToCheck: string) {
        return this.isNumeric(ruleToCheck.substring(0, 2));
    }

    // determines if a string value is numeric
    isNumeric(value: string) {
        return /^-{0,1}\d+$/.test(value);
    }
}









    // findAllInstancesMatching(term: string): Array<RuleInstance> {
    //     if (term == null || term == '') {
    //         return this.topics;
    //     } else {
    //         // let temp = [];
    //         let temp = Array<RuleInstance>();
    //         Object.keys(rules).forEach((key) => {
    //             let subrule = rules[key];
    //             Object.keys(subrule).forEach((subkey) => {
    //                 let detail = rules[key][subkey];
    //                 let added = false;
    //                 if (typeof detail !== 'object') {
    //                     detail = [detail];
    //                 }
    //                 detail.forEach((explanation) => {
    //                     if (explanation.toLowerCase().search(term) !== -1 && !added) {
    //                         temp.push(subkey);
    //                         this.searchReference[subkey] = key;
    //                         added = true;
    //                     }
    //                 });
    //             });
    //         });

    //         if (temp.length >= 1) {
    //             return temp;
    //         } else {
    //             return ['No results found :('];
    //         }
    //     }
    // }

    // findAllSubTopicsMatching(
    //     topic: RuleTopic,
    //     term: string
    // ): Array<RuleSubTopic & { title: string }> {
    //     if (term == null || term == '') {
    //         return [];
    //     }
    //     topic = topic || {};
    //     return Object.keys(topic)
    //         .map((key) => ({ title: key, ...topic[key] }))
    //         .filter((sub) => sub.includes(term));
    // }




    // when a rule is clicked, displays the subcategories or detailed rules that category contains
    displaySubrules(rule: string) {
        // if the main rules are currently displayed (default), and a rule is clicked, display all rules its "section" represents, show back button
        this.hideBack = false;
        if (this.array == this.rules.getAllTopicIds()) {
            // sets the back-button label
            this.currentTerm = rule;
            // this.array = this.rules.getAllSubTopicIds(rule);
            this.array = this.rules.getAllSubTopicIds(this.rules.getAllRules()[rule]);

            // when a section is displayed or searched, and a rule is clicked, display all rules its "subsection" represents
        } else if (this.searchReference != {}) {
            // set sectionrule to glossary by default
            this.sectionrule = this.rules.glossary;
            // if not glossary, set sectionrule to appropriate section
            this.array = this.rules.getRuleDetails(rule);
            // this.array = this.rules.findAllSubTopicsMatching(this.rules.topics[rule], rule);
            // this.array = this.rules.findAllInstancesMatching(rule, false);
            this.subsection = this.array;
            this.currentTerm = rule;
        }
    }



    // getTopicIdFromSubtopicId(subtopicLabel: string): string {
    //     for (let i = 0; i < this.topics.length; i++) {
    //         if (this.topics[i].startsWith(subtopicLabel.substring(0, 1))) {
    //             return this.topics[i];
    //         }
    //     }
    // }

    // getAllRulesMatching(searchTerm) {
    //     if (searchTerm == null || searchTerm == '') {
    //         return this.topics;
    //     } else {
    //         let temp = [];
    //         Object.keys(rules).forEach((key) => {
    //             let subrule = rules[key];
    //             Object.keys(subrule).forEach((subkey) => {
    //                 let detail = rules[key][subkey];
    //                 let added = false;
    //                 if (typeof detail !== 'object') {
    //                     detail = [detail];
    //                 }

    //                 detail.forEach((explanation) => {
    //                     if (explanation.toLowerCase().search(searchTerm) !== -1 && !added) {
    //                         temp.push(subkey);
    //                         this.searchReference[subkey] = key;
    //                         added = true;
    //                     }
    //                 });
    //             });
    //         });

    //         if (temp.length >= 1) {
    //             return temp;
    //         } else {
    //             return ['No results found :('];
    //         }
    //     }
    // }

    // getRuleSecById(sectionrule: string) {
    //     return Object.keys(rules[sectionrule]);
    // }
}